/*

Нека си припомним как работеха алгоритмите на Дийкстра и Прим
по двата псевдокода

Обяснете стъпка по стъпка как ще протекат те върху графа на
картинката започвайки от връх 1. Покажете какво е покриващото
дърво, което се получава в двата случая и как то се репрезентира в
масива p. Най-добре ще е на всяка стъпка да показвате как се
променя този масив както и другия помощен масив dist, който при
алгоритъма на Дийкстра съдържа информация за текущите
разстояния от стартовия връх, а при този на Прим пази теглата на
текущите най-леки ребра свързващи върховете.

---------------------------------------------------------------------------------------------------------------------------------------------------


Идеята на тези два алгоритъма е, че Дийкстра търси най краткия път спрямо няй малката тежест, а Прим просто тъсри пътя с най малка тежест

1. Инициализираме си dist[v] за всеки връх v , освен за началния връх, който се инициализира с 0.
2. Инициализирай visited[v] (S) за всеки връх v със стойност "непосетен".
3. И сега в един цикъл се въртят следните стъпки
    - Избераме непосетения връх u с най-малка стойност на dist[u].
    - Посети върха u.
    - За всеки съседен връх v на u, ако dist[u] + теглото на реброто от u до v е по-малко от текущата стойност на dist[v], обнови dist[v].
4. вътим докато има непосетени върхове.

как горе долу работи алгоритм като стъпки: 

1: Инициализация на `dist` и `p`. Началният връх е връх 1, следователно `dist[1]` се инициализира с 0.

2: Избираме върха с най-малко разстояние към началния връх, който е връх 1. И след това обновяваме съседните върхове.
3: Избирме си следващия върха с най-малко разстояние, който е връх 2. и съответно обноявавме съседните върхове.
4: Избираме си следващия върха с най-малко разстояние, който е връх 3.
5: и тн.

И свъшва, когатпо няма повече непосетени върхове.

------------------------------------------------------------------------------------------------

Алгоритъмът на Прим се използва за намиране на минимално покриващо дърво .  започва с един връх и постепенно добавя ребра към покриващото дърво, като избира ребрата с най-малко тегло и добавя съответните върхове към множеството от вече обходени върхове. 


1. Избераме произволен връх v или стартовия и го добавявме към множеството на обходените върхове.
2. И сега започваме да повтаряме следните стъпки:
    - Избераме ребро с най-малко тегло където имаме два върха единия е визитнат а другия не.
    - Добавявме не визитния врух кум към множеството на обходените върхове и реброто към покриващото дърво.
3. и това го правим докато не се добавят всички върхове към покриващото дърво.


Протичането на това нещо ще стане по следните стъпки:


p: [-1, -1, и тн.] Масивът p показва предшественика на всеки връх по пътя
dist: [inf, inf и тн.] дист показва еглата на текущите най-леки ребра

1: Избираме произволен връх, например връх 1, и го добавяме към множеството на обходените върхове.
2: Избираме ребро с най-малко тегло (примерно връзката между връх 1 и връх 2 с тегло 3) и го добавяме към покриващото дърво.
3: Избираме следващото ребро с най-малко тегло (което в моя примерен случай ще бъде връзката между връх 1 и връх 4 с тегло 5) и го добавяме към покриващото дърво.
4:и тн.
Алгоритъмът свършва,когато всички върхове са добавени към покриващото дърво.Така покриващото дърво се представя чрез масива `p`, като `-1` означава, чевърхът няма предшественик, а останалите елементи показват предшественика на всеки връх по пътя от началния връх.


В начлото ще бъде така: 
p: [-1, -1, -1, -1, ]
dist: [inf, inf, inf, inf, inf]

В края ще бъде попълнен със съответни стойности (не ми стигна времето)



*/