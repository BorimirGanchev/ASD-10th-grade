#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

/*
    Коментар обяснение: Написал съм го в кода всичко за алгоритъма, че там ще ми е по лесно
    
    Също компилатора ми ми дава някакви грешки с ютил така че само ще имплементирам алгоритъма

*/

/*Дадена е NxN матрица номерирана от 0 до n2 -1 започвайки отгоре в
ляво. Дъската представлява игра на “Стълби и змии”. Ако на някое
поле има стълба тя ви пренася напред, ако е змия ви връща назад.
Започвате от поле 0. Всеки ход имате избор измежду 6 стъпки,
симулирайки мятане на зар от 1 до 6 и всяка стъпка ви мести
напред със 1-6 полета. Полетата, които нямат змия или стълба са
отбелязани в матрицата с -1, а тези, които имат съдържат число от 0
до n2 -1. След придвижване напред ако на достигнатото поле има
змия или стълба тя задължително ви мести на съответното поле
отбелязано в матрицата.
Да се изведе минималният брой движения нужни за да се достигне
финалното поле n2 -1. Ако това не е възможно да се изведе -1.
На поле 0 и n2 -1 е гарантирано, че няма змия или стълба. Всеки ход
може да минете през максимум една змия или стълба. Тоест ако
след минаване по стълба, полето, което е достигнато има друга
стълба или змия не продължавате по нея.*/

int snakesAndLadders(int** board, int N) {
    //спестявам си обяснението на първата част, но като цяло просто инициализираме 
    bool visited[N * N];
    for (int i = 0; i < N * N; i++) {
        visited[i] = false;
    }
    struct QueueNode {
        int position;
        int moves;
    };
    struct QueueNode queue[N * N];
    int front = 0, rear = 0;
    
    queue[rear++] = (struct QueueNode){0, 0};
    visited[0] = true;
    
    // тук си праввя бфс то 
    while (front < rear) {
        struct QueueNode current = queue[front+];
        int currentPosition = current.position;
        int currentMoves = current.moves;
        // тук проверявам за всчики възможности за зарчето демек от 1 до 6
        for (int i = 1; i <= 6; i++) {
            int nextPosition = currentPosition + i;
            // проверявам си дали съм стигнал опоследното поле
            if (nextPosition >= N * N - 1) {
                return currentMoves + 1;
            }
            // проверявам дали следващата ми позиция е адекватна, демек не е визитната и е валидна
            if (nextPosition < N * N && !visited[nextPosition]) {

                printf("chek");
                visited[nextPosition] = true;
                // ако стигна до стълба или змия тук променям позицията си, тоест я сменям с там дето стига змията или стълбата  
                if (board[nextPosition / N][nextPosition % N] != -1) {

                    //сега тук не сум много сигурен дали е правилна логиката 
                    nextPosition = board[nextPosition / N][nextPosition % N];
                    visited[nextPosition] = true;
                }
                // местя се
                queue[rear++] = (struct QueueNode){nextPoition, currentMoves + 1};
            }
        }
    }

    /*
Инициализацията на масива за посетени върхове е O(V) . Поставянето на началния връх в опашката изисква си е O(1).Обхождането на всеки връх и неговите съседи е O(E). Тъй като всеки връх може да бъде добавен в опашката най-много веднъж, работата на цикъла пак е O(E). И се плучвава май O(V + E).


сега това може да не го приемате, че не съм много сигърен но май в случай на тази задача Eтата може да бъдат повече от Vtata, ако има много ребра на дъската, можем да кажем, че сложността е O(E).*/
    
    return -1;
}



int main()
{
    /*
    [
        [-1, 14, -1, -1, -1, -1],
        [-1,  -1, -1, -1, -1, -1],
        [-1,  31, -1, -1, 12, -1],
        [-1,  -1, -1, -1, -1, -1],
        [-1,  -1, -1, -1, -1, -1],
        [-1,  -1, -1, -1, -1, -1],
    ]
    Should be 4
    */
    printf("%d - example from description\n", snakesAndLadders((int *[]){
        (int[6]){-1, 14, -1, -1, -1, -1},
        (int[6]){-1, -1, -1, -1, -1, -1},
        (int[6]){-1, 31, -1, -1, 12, -1},
        (int[6]){-1, -1, -1, -1, -1, -1},
        (int[6]){-1, -1, -1, -1, -1, -1},
        (int[6]){-1, -1, -1, -1, -1, -1},
    }, 6)); // 4
    /* [
        [-1, 2],
        [-1,-1],
       ]

       Should be 1
    */
    printf("%d - [[-1,2],[-1,-1]]\n", snakesAndLadders((int *[]){
        (int[2]){-1, 2},
        (int[2]){-1, -1},
    }, 2)); // 1

    /*
    [
        [-1, -1, 1],
        [1,  1,  1],
        [1,  1,  -1],
    ]
    Should be impossible: -1
    */
    printf("%d - impossible \n", snakesAndLadders((int *[]){
        (int[3]){-1, -1, 1},
        (int[3]){1, 1, 1},
        (int[3]){1, 1, -1},
    }, 3)); // -1

    return -1;
}

